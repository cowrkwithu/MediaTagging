# 구현 설계서

**프로젝트명:** editVideoTagging
**버전:** v20260126172234
**작성일:** 2026-01-26

---

## 1. 개요

본 문서는 동영상 태깅 및 검색 웹 애플리케이션의 단계별 구현 계획을 정의한다.
각 단계는 구현 완료 후 테스트를 수행하고, 테스트 결과를 기록한 후 다음 단계로 진행한다.

---

## 2. 현재 구현 상태

### 2.1 완료된 항목

| 구분 | 항목 | 상태 |
|------|------|------|
| 인프라 | PostgreSQL Docker 컨테이너 | ✅ 완료 |
| 인프라 | DB 마이그레이션 (Alembic) | ✅ 완료 |
| 백엔드 | FastAPI 기본 구조 | ✅ 완료 |
| 백엔드 | 비디오 업로드 API | ✅ 완료 |
| 백엔드 | 비디오 CRUD API | ✅ 완료 |
| 백엔드 | Ollama 클라이언트 유틸리티 | ✅ 완료 |
| 백엔드 | FFmpeg 유틸리티 | ✅ 완료 |
| 프론트엔드 | Next.js 기본 구조 | ✅ 완료 |
| 프론트엔드 | 업로드 페이지 (진행률 표시) | ✅ 완료 |
| 프론트엔드 | 비디오 목록/상세 페이지 | ✅ 완료 |
| 프론트엔드 | 검색 페이지 UI | ✅ 완료 |

### 2.2 테스트 완료 항목

| 테스트 항목 | 결과 | 테스트 일시 |
|-------------|------|-------------|
| 비디오 업로드 API | ✅ 성공 | 2026-01-26 17:12 |
| 파일 저장 확인 | ✅ 성공 | 2026-01-26 17:12 |
| DB 저장 확인 | ✅ 성공 | 2026-01-26 17:12 |
| 비디오 목록 조회 | ✅ 성공 | 2026-01-26 17:14 |
| 프론트엔드 프록시 | ✅ 성공 | 2026-01-26 17:14 |

---

## 3. 구현 단계 개요

```
Phase 1: 비디오 메타데이터 자동 생성
    ├── Step 1.1: 비디오 정보 자동 추출 (duration, file_size)
    ├── Step 1.2: Ollama 연동 - 비디오 요약 생성
    └── Step 1.3: Ollama 연동 - 비디오 태그 생성

Phase 2: 장면 분할 및 태깅
    ├── Step 2.1: PySceneDetect 장면 감지
    ├── Step 2.2: 장면별 썸네일/클립 생성
    └── Step 2.3: 장면별 태그 생성

Phase 3: 검색 기능
    ├── Step 3.1: 태그 목록 API
    ├── Step 3.2: AND/OR/NOT 검색 로직
    └── Step 3.3: 프론트엔드 검색 연동

Phase 4: 장면 내보내기
    ├── Step 4.1: 장면 상세 조회 API
    ├── Step 4.2: 장면 다운로드 API
    └── Step 4.3: 장면 병합 내보내기

Phase 5: 비디오 플레이어
    ├── Step 5.1: React Player 통합
    ├── Step 5.2: 장면 타임라인 표시
    └── Step 5.3: 장면 클릭 시 해당 위치 이동

Phase 6: UI/UX 개선
    ├── Step 6.1: 실시간 처리 상태 표시
    ├── Step 6.2: 에러 처리 개선
    └── Step 6.3: 반응형 디자인 점검
```

---

## 4. Phase 1: 비디오 메타데이터 자동 생성

### 4.1 목표
- 업로드된 비디오의 메타데이터를 자동으로 추출하고 AI 기반 요약/태그 생성

### 4.2 관련 요구사항
- FR-001: 동영상 업로드
- FR-002: 자동 메타데이터 생성

---

### Step 1.1: 비디오 정보 자동 추출

#### 구현 내용
| 파일 | 수정 내용 |
|------|-----------|
| `backend/app/api/routes/videos.py` | 업로드 시 FFmpeg로 duration 추출 |
| `backend/app/utils/video_processor.py` | get_video_info() 활용 |

#### 구현 상세
```python
# videos.py upload_video 함수에 추가
from app.utils.video_processor import VideoProcessor

processor = VideoProcessor()
video_info = processor.get_video_info(file_path)
video.duration = video_info.get('duration')
```

#### 테스트 계획
| 테스트 케이스 | 예상 결과 |
|---------------|-----------|
| MP4 파일 업로드 | duration 값이 DB에 저장됨 |
| MKV 파일 업로드 | duration 값이 DB에 저장됨 |
| 잘못된 파일 업로드 | 에러 메시지 반환 |

#### 테스트 결과
| 테스트 케이스 | 결과 | 일시 | 비고 |
|---------------|------|------|------|
| MP4 파일 업로드 | ✅ 성공 | 2026-01-26 17:28 | duration: 5초 정확히 추출 |
| DB 저장 확인 | ✅ 성공 | 2026-01-26 17:28 | duration 필드에 5 저장됨 |

---

### Step 1.2: Ollama 연동 - 비디오 요약 생성

#### 구현 내용
| 파일 | 수정 내용 |
|------|-----------|
| `backend/app/services/tagging_service.py` | 태깅 서비스 생성 |
| `backend/app/api/routes/videos.py` | tagging/start에서 요약 생성 호출 |

#### 구현 상세
```python
# tagging_service.py
class TaggingService:
    def __init__(self):
        self.ollama = OllamaClient()
        self.processor = VideoProcessor()

    async def generate_summary(self, video_id: UUID, db: Session):
        video = db.query(Video).filter(Video.id == video_id).first()
        # 비디오에서 키프레임 추출
        frames = self.processor.extract_keyframes(video.file_path)
        # Ollama로 요약 생성
        summary = await self.ollama.generate_summary(frames)
        video.summary = summary
        db.commit()
```

#### 의존성
- Ollama 서버 실행 중 (localhost:11434)
- 모델: gemma3:27b 또는 qwen3:14b

#### 테스트 계획
| 테스트 케이스 | 예상 결과 |
|---------------|-----------|
| 태깅 시작 요청 | summary 필드가 업데이트됨 |
| Ollama 미실행 시 | 적절한 에러 메시지 |

#### 테스트 결과
| 테스트 케이스 | 결과 | 일시 | 비고 |
|---------------|------|------|------|
| 태깅 시작 요청 | ✅ 성공 | 2026-01-26 17:32 | summary 필드 업데이트됨 |
| Ollama 연동 | ✅ 성공 | 2026-01-26 17:32 | qwen3:14b 모델 사용 |

---

### Step 1.3: Ollama 연동 - 비디오 태그 생성

#### 구현 내용
| 파일 | 수정 내용 |
|------|-----------|
| `backend/app/services/tagging_service.py` | generate_video_tags() 메서드 추가 |
| `backend/app/api/routes/videos.py` | 태그 저장 로직 |

#### 구현 상세
```python
async def generate_video_tags(self, video_id: UUID, db: Session):
    video = db.query(Video).filter(Video.id == video_id).first()
    # 키프레임 기반 태그 생성
    tags = await self.ollama.generate_tags(context)

    for tag_name in tags:
        # 기존 태그 확인 또는 생성
        tag = db.query(Tag).filter(Tag.name == tag_name).first()
        if not tag:
            tag = Tag(name=tag_name)
            db.add(tag)

        # VideoTag 연결
        video_tag = VideoTag(video_id=video.id, tag_id=tag.id)
        db.add(video_tag)

    db.commit()
```

#### 테스트 계획
| 테스트 케이스 | 예상 결과 |
|---------------|-----------|
| 태깅 완료 후 | video_tags 테이블에 레코드 생성 |
| 중복 태그 | 기존 태그 재사용 |

#### 테스트 결과
| 테스트 케이스 | 결과 | 일시 | 비고 |
|---------------|------|------|------|
| 태깅 완료 후 | ✅ 성공 | 2026-01-26 17:32 | video_tags 테이블에 9개 레코드 생성 |
| tags 테이블 | ✅ 성공 | 2026-01-26 17:32 | 9개 태그 생성 (한글) |

---

## 5. Phase 2: 장면 분할 및 태깅

### 5.1 목표
- 비디오를 장면 단위로 분할하고 각 장면에 태그 생성

### 5.2 관련 요구사항
- FR-004: 장면 단위 분할
- FR-005: 장면별 타임스탬프 생성
- FR-006: 장면별 태그 생성

---

### Step 2.1: PySceneDetect 장면 감지

#### 구현 내용
| 파일 | 수정 내용 |
|------|-----------|
| `backend/app/utils/scene_detector.py` | 신규 생성 |
| `backend/app/services/tagging_service.py` | 장면 감지 호출 |

#### 구현 상세
```python
# scene_detector.py
from scenedetect import detect, ContentDetector

class SceneDetector:
    def detect_scenes(self, video_path: str) -> list[tuple[float, float]]:
        """장면 감지 후 (시작시간, 종료시간) 튜플 리스트 반환"""
        scene_list = detect(video_path, ContentDetector())
        return [(scene[0].get_seconds(), scene[1].get_seconds())
                for scene in scene_list]
```

#### 테스트 계획
| 테스트 케이스 | 예상 결과 |
|---------------|-----------|
| 일반 비디오 | 장면 리스트 반환 |
| 단일 장면 비디오 | 1개 장면 반환 |
| 긴 비디오 (10분+) | 성능 확인 (30초 이내) |

#### 테스트 결과
| 테스트 케이스 | 결과 | 일시 | 비고 |
|---------------|------|------|------|
| 일반 비디오 (3씬) | ✅ 성공 | 2026-01-26 17:44 | 3개 씬 정확히 감지 (0-3s, 3-6s, 6-9s) |
| 단일 장면 비디오 | ✅ 성공 | 2026-01-26 17:44 | 씬 감지 없으면 전체를 1개 씬으로 처리 |

---

### Step 2.2: 장면별 썸네일/클립 생성

#### 구현 내용
| 파일 | 수정 내용 |
|------|-----------|
| `backend/app/services/tagging_service.py` | 장면 저장 및 썸네일/클립 생성 |

#### 구현 상세
```python
async def process_scenes(self, video_id: UUID, db: Session):
    video = db.query(Video).filter(Video.id == video_id).first()
    scenes = self.scene_detector.detect_scenes(video.file_path)

    for i, (start, end) in enumerate(scenes):
        # 썸네일 생성
        thumbnail_path = f"{settings.storage_path}/thumbnails/{video_id}_{i}.jpg"
        self.processor.extract_thumbnail(video.file_path, start + 1, thumbnail_path)

        # 클립 생성
        clip_path = f"{settings.storage_path}/clips/{video_id}_{i}.mp4"
        self.processor.extract_clip(video.file_path, start, end, clip_path)

        # DB 저장
        scene = Scene(
            video_id=video.id,
            start_time=start,
            end_time=end,
            thumbnail_path=thumbnail_path,
            clip_path=clip_path
        )
        db.add(scene)

    db.commit()
```

#### 테스트 계획
| 테스트 케이스 | 예상 결과 |
|---------------|-----------|
| 장면 처리 완료 | scenes 테이블에 레코드 생성 |
| 썸네일 파일 | storage/thumbnails/에 JPG 파일 생성 |
| 클립 파일 | storage/clips/에 MP4 파일 생성 |

#### 테스트 결과
| 테스트 케이스 | 결과 | 일시 | 비고 |
|---------------|------|------|------|
| 장면 처리 완료 | ✅ 성공 | 2026-01-26 17:45 | scenes 테이블에 3개 레코드 생성 |
| 썸네일 파일 | ✅ 성공 | 2026-01-26 17:45 | storage/thumbnails/{video_id}/ 에 3개 JPG 생성 |
| 클립 파일 | ⏸️ 보류 | - | 현재 썸네일만 생성, 클립은 필요 시 생성 |

---

### Step 2.3: 장면별 태그 생성

#### 구현 내용
| 파일 | 수정 내용 |
|------|-----------|
| `backend/app/services/tagging_service.py` | 장면별 태그 생성 로직 |

#### 구현 상세
```python
async def generate_scene_tags(self, video_id: UUID, db: Session):
    scenes = db.query(Scene).filter(Scene.video_id == video_id).all()

    for scene in scenes:
        # 장면 썸네일 기반 태그 생성
        tags = await self.ollama.generate_tags(scene.thumbnail_path)

        for tag_name in tags[:10]:  # 최대 10개
            tag = db.query(Tag).filter(Tag.name == tag_name).first()
            if not tag:
                tag = Tag(name=tag_name)
                db.add(tag)
                db.flush()

            scene_tag = SceneTag(scene_id=scene.id, tag_id=tag.id)
            db.add(scene_tag)

    db.commit()
```

#### 테스트 계획
| 테스트 케이스 | 예상 결과 |
|---------------|-----------|
| 태깅 완료 후 | scene_tags 테이블에 레코드 생성 |
| 태그 수 | 장면당 1~10개 |

#### 테스트 결과
| 테스트 케이스 | 결과 | 일시 | 비고 |
|---------------|------|------|------|
| 태깅 완료 후 | ✅ 성공 | 2026-01-26 17:45 | scene_tags 테이블에 레코드 생성 |
| 태그 수 | ✅ 성공 | 2026-01-26 17:45 | 장면당 5개 태그 생성 (총 15개) |

---

## 6. Phase 3: 검색 기능

### 6.1 목표
- 태그 기반 AND/OR/NOT 검색 구현

### 6.2 관련 요구사항
- FR-009: 키워드 검색
- FR-010: 논리 연산자 지원
- FR-011: 검색 대상

---

### Step 3.1: 태그 목록 API

#### 구현 내용
| 파일 | 수정 내용 |
|------|-----------|
| `backend/app/api/routes/search.py` | GET /tags 구현 |

#### 구현 상세
```python
@router.get("/tags", response_model=List[TagResponse])
async def get_tags(db: Session = Depends(get_db)):
    tags = db.query(Tag).order_by(Tag.name).all()
    return tags
```

#### 테스트 계획
| 테스트 케이스 | 예상 결과 |
|---------------|-----------|
| 태그 목록 조회 | 모든 태그 반환 |
| 빈 태그 목록 | 빈 배열 반환 |

#### 테스트 결과
| 테스트 케이스 | 결과 | 일시 | 비고 |
|---------------|------|------|------|
| 태그 목록 조회 | ✅ 성공 | 2026-01-26 17:50 | 19개 태그, video_count/scene_count 포함 |
| 정렬 | ✅ 성공 | 2026-01-26 17:50 | 사용 빈도순 정렬 |

---

### Step 3.2: AND/OR/NOT 검색 로직

#### 구현 내용
| 파일 | 수정 내용 |
|------|-----------|
| `backend/app/services/search_service.py` | 신규 생성 |
| `backend/app/api/routes/search.py` | POST / 검색 구현 |

#### 구현 상세
```python
# search_service.py
class SearchService:
    def search(self, query: SearchQuery, db: Session) -> SearchResult:
        video_ids = set()
        scene_ids = set()

        # AND 조건: 모든 태그를 포함하는 비디오/장면
        if query.query.and_tags:
            video_ids = self._search_videos_and(query.query.and_tags, db)
            scene_ids = self._search_scenes_and(query.query.and_tags, db)

        # OR 조건: 태그 중 하나라도 포함
        if query.query.or_tags:
            or_videos = self._search_videos_or(query.query.or_tags, db)
            or_scenes = self._search_scenes_or(query.query.or_tags, db)
            video_ids = video_ids.union(or_videos) if video_ids else or_videos
            scene_ids = scene_ids.union(or_scenes) if scene_ids else or_scenes

        # NOT 조건: 특정 태그 제외
        if query.query.not_tags:
            exclude_videos = self._search_videos_or(query.query.not_tags, db)
            exclude_scenes = self._search_scenes_or(query.query.not_tags, db)
            video_ids = video_ids - exclude_videos
            scene_ids = scene_ids - exclude_scenes

        return SearchResult(
            videos=list(video_ids),
            scenes=list(scene_ids),
            total=len(video_ids) + len(scene_ids)
        )
```

#### 테스트 계획
| 테스트 케이스 | 예상 결과 |
|---------------|-----------|
| AND 검색 (태그A AND 태그B) | 두 태그 모두 포함된 결과 |
| OR 검색 (태그A OR 태그B) | 하나 이상 포함된 결과 |
| NOT 검색 (NOT 태그A) | 태그A 제외한 결과 |
| 복합 검색 | 올바른 결과 반환 |

#### 테스트 결과
| 테스트 케이스 | 결과 | 일시 | 비고 |
|---------------|------|------|------|
| AND 검색 | ✅ 성공 | 2026-01-26 17:50 | "테스트 영상 AND 짧은 영상" → 2건 |
| OR 검색 | ✅ 성공 | 2026-01-26 17:50 | "5초 영상 OR 9초 영상" → 2건 |
| NOT 검색 | ✅ 성공 | 2026-01-26 17:50 | "테스트 영상 NOT 9초 영상" → 1건 |
| 씬 검색 | ✅ 성공 | 2026-01-26 17:50 | "편집 자료" → 2개 씬 |

---

### Step 3.3: 프론트엔드 검색 연동

#### 구현 내용
| 파일 | 수정 내용 |
|------|-----------|
| `frontend/src/app/search/page.tsx` | 실제 API 연동 |
| `frontend/src/lib/api.ts` | search, getTags 함수 확인 |

#### 테스트 계획
| 테스트 케이스 | 예상 결과 |
|---------------|-----------|
| 검색 실행 | 검색 결과 표시 |
| 결과 클릭 | 해당 비디오/장면으로 이동 |

#### 테스트 결과
| 테스트 케이스 | 결과 | 일시 | 비고 |
|---------------|------|------|------|
| 태그 목록 표시 | ✅ 성공 | 2026-01-26 17:52 | 상위 10개 태그 버튼으로 표시 |
| API 프록시 | ✅ 성공 | 2026-01-26 17:52 | /api/search/* 정상 연동 |
| 타입 정의 | ✅ 성공 | 2026-01-26 17:52 | SearchQuery, SearchResult 백엔드 맞춤 |

---

## 7. Phase 4: 장면 내보내기

### 7.1 목표
- 선택한 장면을 개별 영상으로 다운로드하거나 병합하여 내보내기

### 7.2 관련 요구사항
- FR-007: 장면 선택
- FR-008: 개별 영상 저장

---

### Step 4.1: 장면 상세 조회 API

#### 구현 내용
| 파일 | 수정 내용 |
|------|-----------|
| `backend/app/api/routes/scenes.py` | GET /{scene_id} 구현 |
| `backend/app/schemas/scene.py` | SceneDetailResponse 추가 |

#### 테스트 계획
| 테스트 케이스 | 예상 결과 |
|---------------|-----------|
| 존재하는 장면 조회 | 장면 정보 + 태그 반환 |
| 존재하지 않는 장면 | 404 에러 |

#### 테스트 결과
| 테스트 케이스 | 결과 | 일시 | 비고 |
|---------------|------|------|------|
| 존재하는 장면 조회 | ✅ 성공 | 2026-01-26 18:03 | 장면 정보 + 5개 태그 반환 |
| API 응답 필드 | ✅ 성공 | 2026-01-26 18:03 | duration, video_filename 포함 |

---

### Step 4.2: 장면 다운로드 API

#### 구현 내용
| 파일 | 수정 내용 |
|------|-----------|
| `backend/app/api/routes/scenes.py` | GET /{scene_id}/download 구현 |

#### 구현 상세
```python
from fastapi.responses import FileResponse

@router.get("/{scene_id}/download")
async def download_scene(scene_id: UUID, db: Session = Depends(get_db)):
    scene = db.query(Scene).filter(Scene.id == scene_id).first()
    if not scene or not scene.clip_path:
        raise HTTPException(status_code=404, detail="Scene clip not found")

    return FileResponse(
        scene.clip_path,
        media_type="video/mp4",
        filename=f"scene_{scene_id}.mp4"
    )
```

#### 테스트 계획
| 테스트 케이스 | 예상 결과 |
|---------------|-----------|
| 클립 다운로드 | MP4 파일 다운로드 |
| 클립 없는 장면 | 404 에러 |

#### 테스트 결과
| 테스트 케이스 | 결과 | 일시 | 비고 |
|---------------|------|------|------|
| 클립 다운로드 | ✅ 성공 | 2026-01-26 18:06 | 5초 MP4 파일 다운로드 |
| 온디맨드 생성 | ✅ 성공 | 2026-01-26 18:06 | clip_path 없을 시 자동 생성 |

---

### Step 4.3: 장면 병합 내보내기

#### 구현 내용
| 파일 | 수정 내용 |
|------|-----------|
| `backend/app/api/routes/scenes.py` | POST /export 구현 |
| `backend/app/utils/video_processor.py` | merge_clips() 메서드 추가 |

#### 구현 상세
```python
# video_processor.py
def merge_clips(self, clip_paths: list[str], output_path: str):
    """여러 클립을 하나의 영상으로 병합"""
    # FFmpeg concat 사용
    ...

# scenes.py
@router.post("/export")
async def export_scenes(
    scene_ids: List[UUID],
    db: Session = Depends(get_db)
):
    scenes = db.query(Scene).filter(Scene.id.in_(scene_ids)).all()
    clip_paths = [s.clip_path for s in scenes if s.clip_path]

    output_path = f"{settings.storage_path}/exports/{uuid4()}.mp4"
    processor.merge_clips(clip_paths, output_path)

    return FileResponse(output_path, media_type="video/mp4")
```

#### 테스트 계획
| 테스트 케이스 | 예상 결과 |
|---------------|-----------|
| 2개 장면 병합 | 병합된 영상 다운로드 |
| 5개 장면 병합 | 병합된 영상 다운로드 |

#### 테스트 결과
| 테스트 케이스 | 결과 | 일시 | 비고 |
|---------------|------|------|------|
| 3개 장면 개별 내보내기 | ✅ 성공 | 2026-01-26 18:08 | 3개 클립 파일 생성 |
| 3개 장면 병합 | ✅ 성공 | 2026-01-26 18:08 | 9초 병합 파일 생성 (3x3초) |
| 클립 재인코딩 | ✅ 성공 | 2026-01-26 18:08 | libx264로 정확한 구간 추출 |

---

## 8. Phase 5: 비디오 플레이어

### 8.1 목표
- 비디오 재생 및 장면 타임라인 연동

### 8.2 관련 요구사항
- NFR-002: 사용자 인터페이스

---

### Step 5.1: React Player 통합

#### 구현 내용
| 파일 | 수정 내용 |
|------|-----------|
| `frontend/src/components/VideoPlayer.tsx` | 신규 생성 |
| `frontend/src/app/videos/[id]/page.tsx` | VideoPlayer 컴포넌트 사용 |

#### 구현 상세
```typescript
// VideoPlayer.tsx
'use client';

import ReactPlayer from 'react-player';
import { useRef, useState } from 'react';

interface VideoPlayerProps {
  url: string;
  onProgress?: (state: { playedSeconds: number }) => void;
}

export function VideoPlayer({ url, onProgress }: VideoPlayerProps) {
  const playerRef = useRef<ReactPlayer>(null);

  const seekTo = (seconds: number) => {
    playerRef.current?.seekTo(seconds);
  };

  return (
    <ReactPlayer
      ref={playerRef}
      url={url}
      controls
      width="100%"
      height="100%"
      onProgress={onProgress}
    />
  );
}
```

#### 테스트 계획
| 테스트 케이스 | 예상 결과 |
|---------------|-----------|
| 비디오 재생 | 정상 재생 |
| 일시정지/재생 | 정상 동작 |
| 시간 이동 | 정상 이동 |

#### 테스트 결과
| 테스트 케이스 | 결과 | 일시 | 비고 |
|---------------|------|------|------|
| 비디오 스트리밍 | ✅ 성공 | 2026-01-26 18:18 | Range 요청 지원, MP4 스트리밍 |
| VideoPlayer 컴포넌트 | ✅ 성공 | 2026-01-26 18:18 | react-player 기반, 커스텀 컨트롤 |

---

### Step 5.2: 장면 타임라인 표시

#### 구현 내용
| 파일 | 수정 내용 |
|------|-----------|
| `frontend/src/components/SceneTimeline.tsx` | 신규 생성 |

#### 테스트 계획
| 테스트 케이스 | 예상 결과 |
|---------------|-----------|
| 장면 구간 표시 | 타임라인에 장면 구간 시각화 |
| 현재 재생 위치 | 현재 위치 표시 |

#### 테스트 결과
| 테스트 케이스 | 결과 | 일시 | 비고 |
|---------------|------|------|------|
| SceneTimeline 컴포넌트 | ✅ 성공 | 2026-01-26 18:18 | 장면별 색상 구분, 현재 위치 표시 |
| 장면 구간 시각화 | ✅ 성공 | 2026-01-26 18:18 | 타임라인 바 + 장면 버튼 |

---

### Step 5.3: 장면 클릭 시 해당 위치 이동

#### 구현 내용
| 파일 | 수정 내용 |
|------|-----------|
| `frontend/src/app/videos/[id]/page.tsx` | 장면 클릭 핸들러 |

#### 테스트 계획
| 테스트 케이스 | 예상 결과 |
|---------------|-----------|
| 장면 클릭 | 해당 시간으로 이동 |
| 썸네일 클릭 | 해당 시간으로 이동 |

#### 테스트 결과
| 테스트 케이스 | 결과 | 일시 | 비고 |
|---------------|------|------|------|
| 장면 클릭 | ✅ 성공 | 2026-01-26 18:18 | playerRef.seekTo() 사용 |
| 장면 다운로드 | ✅ 성공 | 2026-01-26 18:18 | 장면 목록에 다운로드 버튼 추가 |

---

## 9. Phase 6: UI/UX 개선

### 9.1 목표
- 사용자 경험 개선

### 9.2 관련 요구사항
- NFR-002: 사용자 인터페이스
- NFR-003: 응답 시간

---

### Step 6.1: 실시간 처리 상태 표시

#### 구현 내용
| 파일 | 수정 내용 |
|------|-----------|
| `frontend/src/hooks/useTaggingStatus.ts` | 폴링 훅 생성 |
| `frontend/src/app/videos/[id]/page.tsx` | 상태 자동 갱신 |

#### 구현 상세
```typescript
// useTaggingStatus.ts
export function useTaggingStatus(videoId: string) {
  return useQuery({
    queryKey: ['tagging-status', videoId],
    queryFn: () => getTaggingStatus(videoId),
    refetchInterval: (data) =>
      data?.status === 'processing' ? 2000 : false,
  });
}
```

#### 테스트 계획
| 테스트 케이스 | 예상 결과 |
|---------------|-----------|
| 처리 중 상태 | 2초마다 상태 갱신 |
| 완료 상태 | 폴링 중지 |

#### 테스트 결과
| 테스트 케이스 | 결과 | 일시 | 비고 |
|---------------|------|------|------|
| 상태 폴링 훅 | ✅ 성공 | 2026-01-26 18:25 | useTaggingStatus 훅 구현 |
| ProcessingStatus 컴포넌트 | ✅ 성공 | 2026-01-26 18:25 | 상태별 아이콘/색상 표시 |
| 자동 데이터 갱신 | ✅ 성공 | 2026-01-26 18:25 | 처리 완료 시 자동 새로고침 |

---

### Step 6.2: 에러 처리 개선

#### 구현 내용
| 파일 | 수정 내용 |
|------|-----------|
| `frontend/src/components/ErrorBoundary.tsx` | 신규 생성 |
| `frontend/src/app/layout.tsx` | ErrorBoundary 적용 |

#### 테스트 계획
| 테스트 케이스 | 예상 결과 |
|---------------|-----------|
| API 에러 | 사용자 친화적 에러 메시지 |
| 네트워크 에러 | 재시도 옵션 제공 |

#### 테스트 결과
| 테스트 케이스 | 결과 | 일시 | 비고 |
|---------------|------|------|------|
| ErrorBoundary | ✅ 성공 | 2026-01-26 18:25 | 에러 캐치 및 재시도 버튼 |
| ToastProvider | ✅ 성공 | 2026-01-26 18:25 | 성공/에러/정보/경고 알림 |
| 슬라이드 애니메이션 | ✅ 성공 | 2026-01-26 18:25 | CSS 애니메이션 적용 |

---

### Step 6.3: 반응형 디자인 점검

#### 테스트 계획
| 화면 크기 | 예상 결과 |
|-----------|-----------|
| Desktop (1920px) | 정상 표시 |
| Tablet (768px) | 정상 표시 |
| Mobile (375px) | 정상 표시 |

#### 테스트 결과
| 화면 크기 | 결과 | 일시 | 비고 |
|-----------|------|------|------|
| Desktop | ✅ 성공 | 2026-01-26 18:25 | 기존 레이아웃 유지 |
| Mobile | ✅ 성공 | 2026-01-26 18:25 | 햄버거 메뉴 추가 |
| 그리드 레이아웃 | ✅ 성공 | 2026-01-26 18:25 | lg:grid-cols-3 반응형 |

---

## 11. 구현 일정 (예상)

| Phase | 예상 소요 | 우선순위 |
|-------|----------|----------|
| Phase 1: 비디오 메타데이터 | - | 높음 |
| Phase 2: 장면 분할 및 태깅 | - | 높음 |
| Phase 3: 검색 기능 | - | 높음 |
| Phase 4: 장면 내보내기 | - | 중간 |
| Phase 5: 비디오 플레이어 | - | 중간 |
| Phase 6: 외부 API 연동 | - | 낮음 |
| Phase 7: UI/UX 개선 | - | 낮음 |

---

## 12. 디렉토리 구조 (최종)

```
editVideoTagging/
├── backend/
│   ├── app/
│   │   ├── api/
│   │   │   └── routes/
│   │   │       ├── videos.py      # 비디오 API
│   │   │       ├── scenes.py      # 장면 API
│   │   │       ├── search.py      # 검색 API
│   │   │       └── external.py    # 외부 API
│   │   ├── models/
│   │   │   ├── database.py
│   │   │   ├── video.py
│   │   │   ├── scene.py
│   │   │   └── tag.py
│   │   ├── schemas/
│   │   │   ├── video.py
│   │   │   ├── scene.py
│   │   │   └── search.py
│   │   ├── services/              # 비즈니스 로직
│   │   │   ├── tagging_service.py
│   │   │   └── search_service.py
│   │   ├── utils/
│   │   │   ├── video_processor.py
│   │   │   ├── scene_detector.py
│   │   │   ├── ollama_client.py
│   │   │   └── nanobana_client.py
│   │   ├── config.py
│   │   └── main.py
│   └── alembic/
├── frontend/
│   └── src/
│       ├── app/
│       │   ├── page.tsx
│       │   ├── upload/page.tsx
│       │   ├── videos/
│       │   │   ├── page.tsx
│       │   │   └── [id]/page.tsx
│       │   └── search/page.tsx
│       ├── components/
│       │   ├── Navbar.tsx
│       │   ├── VideoPlayer.tsx
│       │   ├── SceneTimeline.tsx
│       │   └── ErrorBoundary.tsx
│       ├── hooks/
│       │   └── useTaggingStatus.ts
│       ├── lib/
│       │   ├── api.ts
│       │   └── utils.ts
│       └── types/
│           └── index.ts
├── storage/
│   ├── videos/
│   ├── clips/
│   ├── thumbnails/
│   └── exports/
└── zWorkingDocs/
    ├── 요구사항분석_v20260126151546.md
    ├── 시스템설계_v20260126151726.md
    └── 구현설계_v20260126172234.md
```

---

## 13. 변경 이력

| 버전 | 날짜 | 작성자 | 변경 내용 |
|------|------|--------|----------|
| v20260126172234 | 2026-01-26 | - | 최초 작성 |
